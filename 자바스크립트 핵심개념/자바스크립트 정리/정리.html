<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <b>인터렉티브 자바스크립트</b>

    <p>ch01</p>

    <h1> 유사배열
        이전 시간에 잠깐 등장했던 HTMLCollection 기억나시나요? 배열과 모양은 같지만, 완벽히 배열은 아닌 이런 형태를 유사 배열이라고 부른다고 했었는데요.
        당장은 직접 유사 배열을 만들어서 사용하게 될 일은 없겠지만, 지난 시간처럼 자바스크립트로 HTML 태그를 다룰 때 종종 마주치게 되니깐 간단하게나마 개념적인 부분은 정리하고 넘어갑시다!

        유사 배열(Array-Like Object)이란?
        앞에서도 설명한 것처럼 이름 그대로 배열과 유사(類似)한 객체를 유사 배열, 영어로는 Array-Like Object라고 부릅니다.
        하지만 마냥 모양만 비슷하다고 해서 모두 유사 배열이라고 부르진 않는데요. 유사 배열에도 최소한 갖춰야 할 조건과 특징들이 있습니다.

        1. 숫자 형태의 indexing이 가능하다.
        유사배열-1
        배열은 각 요소에 0부터 순서대로 매겨진 index를 통해 요소끼리의 관계도 파악할 수 있고 그 index를 통해 요소에 접근할 수도 있다는 특징이 있죠?
        유사 배열도 마찬가지로 배열이라는 이름에 걸맞게 각 요소에 0부터 시작하는 숫자 형태의 index가 있어야 합니다.

        2. length 프로퍼티가 있다.
        유사배열-2
        객체가 가지고 있는 요소의 갯수를 저장하는 length 프로퍼티도 역시 배열의 특징이라고 할 수 있는데요. 유사 배열 역시 length 프로퍼티가 있어야 비로소 유사 배열이라고 할 수 있습니다. 숫자
        형태의 index가 있더라도 length 프로퍼티가 없다면 유사 배열이라기보단 그냥 숫자 형태의 key로 구성된 일반적인 객체라고 볼 수 있습니다.

        3. 배열의 기본 메소드를 사용할 수 없다.
        유사배열-3
        상황에 따라서 직접 구현할 수도 있겠지만, 유사 배열이 완전한 배열이 아닌 가장 큰 이유는 바로 기본적인 배열의 메소드를 사용할 수 없다는 점 때문입니다. 배열의 메소드를 활용할 수 없다는 특징이 유사
        배열을 활용하는 목적이 되기도 하는데요. indexing을 통해 유사 배열의 요소에 접근하는 건 쉽지만 수정하거나 삭제하는 작업이 까다롭습니다.
        그래서 내부의 요소들은 배열처럼 다룰 수 있게 하면서 배열의 메소드 사용을 막고 싶거나, 혹은 일반 배열에는 없는 특별한 메소드를 제공하고 싶을 때 유사 배열을 만들어 활용하기도 합니다!

        4. Array.isArray(유사배열)은 false다.
        유사배열-4
        Array 객체의 isArray 메소드는 파라미터로 전달한 값이 배열인지 아닌지를 평가해서 그 결과를 불린 형태의 값으로 리턴해주는 메소드입니다.
        유사 배열은 배열과 비슷하지만 배열은 아니기 때문에 결괏값이 false 입니다.

        주의사항: 유사 배열은 다양하다!
        유사 배열은 위의 특징들을 가진 대부분의 형태를 가리키는 포괄적인 개념이기 때문에 정말 다양한 형태로 존재할 수 있습니다.
        예를 들어 지난 시간에 봤던 HTMLCollection의 경우 for..of 문을 활용하는 데 문제는 없었지만 어떤 유사 배열의 경우에는 for..of문을 활용할 수 없는 경우도 있습니다.
        배열의 기본 메소드를 사용할 수 없다고 했지만, 직접 구현해서 마치 배열처럼 사용할 수 있도록 만들 수도 있습니다.
        하지만 직접 유사 배열을 만드는 게 아니라 이미 만들어진 유사 배열에 접근하는 경우에는 대부분 위 4가지 특징을 모두 가지고 있으니깐 잘 기억해 두시면 좋을 것 같습니다!
    </h1>

    <h2> 태그 이름으로 태그 선택하기
        지금까지 id와 class 속성을 이용해서 JavaScript로 HTML 태그를 선택하는 방법에 대해 알아봤는데요.
        document.getElementsByTagName('태그이름')메소드를 활용하면 태그 이름으로 태그를 선택할 수 있습니다.

        const btns = document.getElementsByTagName('button');
        이렇게 하면 HTML 문서 내에 있는 모든 button 태그를 선택하게 됩니다.

        태그이름으로태그선택하기

        document.getElementsByClassName('class')메소드와 마찬가지로 태그 이름으로 요소를 찾는 경우에 여러 개의 요소가 선택될 수 있기 때문에 메소드 이름에 Element(s),
        s가 있고, 실행결과 역시 HTMLCollection을 리턴한다는 점도 함께 기억해 두시면 좋을 것 같습니다.

        참고로 css 선택자처럼 '*' 값을 전달하게 되면 모든 태그를 선택할 수도 있는데요.

        const btns = document.getElementsByTagName('button');
        const allTags = document.getElementsByTagName('*');
        하지만, css 스타일링을 할 때도 태그 이름으로 스타일링을 하는 경우는 거의 없죠?

        마찬가지로 명확한 의도가 없이 이렇게 많은 요소들을 한꺼번에 다루게 되면 예상치 못한 실수를 할 가능성이 있기 때문에 자바스크립트에서도 많이 사용되는 메소드는 아닙니다.
    </h2>

    <h3> ch01 종합정리
        1. 자바스크립트로 태그 선택하기
        메소드 의미 결과
        document.getElementById('id') HTML id속성으로 태그 선택하기 id에 해당하는 태그 하나
        document.getElementsByClassName('class') HTML class속성으로 태그 선택하기 class에 해당하는 태그 모음(HTMLCollection)
        document.getElementsByTagName('tag') HTML 태그 이름으로 태그 선택하기 tag에 해당하는 태그 모음(HTMLCollection)
        document.querySelector('css') css 선택자로 태그 선택하기 css 선택자에 해당하는 태그 중 가장 첫번째 태그 하나
        document.querySelectorAll('css') css 선택자로 태그 선택하기 css 선택자에 해당하는 태그 모음(NodeList)
        2. 유사 배열이란?
        배열과 유사한 객체 ex) HTMLCollection, NodeList, DOMTokenList, ...
        특징
        숫자 형태의 indexing이 가능하다.
        length 프로퍼티가 있다.
        배열의 기본 메소드를 사용할 수 없다.
        Array.isArray(유사배열)의 리턴값은 false다.
        3. 이벤트와 이벤트 핸들링, 그리고 이벤트 핸들러
        이벤트 : 웹 페이지에서 발생하는 대부분의 일(사건)들
        ex) 버튼 클릭, 스크롤, 키보드 입력, ...

        이벤트 핸들링 : 자바스크립트를 통해 이벤트를 다루는 일

        이벤트 핸들러 : 이벤트가 발생했을 때 일어나야하는 구체적인 동작들을 표현한 코드. 이벤트 리스너(Event Listener)라고도 부른다.

        4. 이벤트 핸들러를 등록하는 2가지 방법
        4-1. 자바스크립트로 해당 DOM 객체의 onclick 프로퍼티에 등록하기
        const btn = document.querySelector('#myBtn');

        btn.onclick = function() {
        console.log('Hello Codeit!');
        };
        4-2. HTML 태그의 onclick 속성에 바로 표시하기
        <button id="myBtn" onclick="console.log('Hello Codeit!')">클릭!</button>
    </h3>

    <b>ch02</b>

    <h1>
        대부분의 브라우저에 있는 개발자 도구는 console.log와 console.dir메소드를 지원합니다.
        두 메소드 모두 파라미터로 전달받은 값을 콘솔에 출력하는 역할을 합니다. 과연 이 둘은 어떤 차이가 있을까요?

        const str = 'Codeit';
        const num = 123;
        const bool = true;
        const arr = [1, 2, 3];
        const obj = {
        name: 'Codeit',
        email: 'codeit@codeit.kr',
        };

        function func() {
        console.log('I love Codeit!');
        }

        console.log('--- str ---');
        console.log(str);
        console.dir(str);
        console.log('--- num ---');
        console.log(num);
        console.dir(num);
        console.log('--- bool ---');
        console.log(bool);
        console.dir(bool);
        console.log('--- arr ---');
        console.log(arr);
        console.dir(arr);
        console.log('--- obj ---');
        console.log(obj);
        console.dir(obj);
        console.log('--- func ---');
        console.log(func);
        console.dir(func);
        console.dir?-1

        이렇게 다양한 유형의 값들을 만들어서 출력 결과를 놓고서 천천히 비교해봅시다.

        1. 출력하는 자료형이 다르다.
        console.dir?-2

        먼저 문자열, 숫자, 불린 부분을 봅시다.
        각 값을 출력할 때 두 번째 dir 부분에서 출력되는 값의 색이 다른 게 보이시나요? dir 메소드는 문자열 표시 형식으로 콘솔에 출력합니다.

        2. log는 값 자체에, dir은 객체의 속성에!
        console.dir?-3

        log 메소드는 파라미터로 전달받은 값을 위주로 출력하는 반면, dir 메소드는 객체의 속성을 좀 더 자세하게 출력합니다.

        dir 메소드가 출력한 부분을 자세히 보면 객체의 유형이 먼저 출력되고, 특히 함수 부분에서는 클릭해서 펼쳤을 때 함수가 가진 속성들을 더 보여주는 모습을 확인할 수 있습니다. (log 메소드는
        펼쳐지지 않음)

        3. log는 여러 개, dir은 하나만!
        console.log(str, num, bool, arr, obj, func);
        console.dir(str, num, bool, arr, obj, func);
        console.dir?-4

        둘 사이의 차이는 파라미터로 전달할 수 있는 값의 개수에도 있는데요.
        log 메소드는 여러 값을 쉼표로 구분해서 전달하면 전달받은 모든 값을 출력하는 반면, dir 메소드는 여러 값을 전달하더라도 첫 번째 값만 출력합니다.

        4. DOM 객체를 다룰 때..
        const myDOM = document.body;

        console.log(myDOM);
        console.dir(myDOM);
        console.dir?-5

        지난 시간에도 확인했듯 log와 dir 메소드의 가장 큰 차이는 DOM 객체를 다룰 때 나타납니다.
        값에 좀 더 중점을 둔 log 메소드는 대상을 HTML 형태로 출력하고, 객체의 속성에 좀 더 중점을 둔 dir 메소드는 대상을 객체 형태로 출력합니다.

        마무리
        지금까지 console 객체의 log 메소드와 dir 메소드의 차이점에 대해 살펴봤는데요.
        콘솔에서 값 자체를 확인하고 싶다면 log메소드를, 객체의 속성들을 살펴보고 싶다면 dir 메소드를 활용하면 좋을 것 같습니다.


    </h1>

    <h2>
        지난 시간에 배운, 요소 노드를 이동시킬 때 사용하는 프로퍼티들을 정리해봅시다.

        요소 노드에 대한 이동 프로퍼티
        프로퍼티 유형 결과
        element.children 자식 요소 노드 element의 자식 요소 모음(HTMLCollection)
        element.firstElementChild 자식 요소 노드 element의 첫 번째 자식 요소 하나
        element.lastElementChild 자식 요소 노드 element의 마지막 자식 요소 하나
        element.parentElement 부모 요소 노드 element의 부모 요소 하나
        element.previousElementSibling 형제 요소 노드 element의 이전(previous) 혹은 좌측(left)에 있는 요소 하나
        element.nextElementSibling 형제 요소 노드 element의 다음(next) 혹은 우측(right)에 있는 요소 하나
        배웠던 그대로 이 프로퍼티들은 노드 중에서도 '요소 노드'인 경우에만 존재하는 프로퍼티들입니다.
        그럼 요소 노드 말고 텍스트 노드에 접근하고 싶을 땐 어떻게 해야 할까요?

        모든 노드에 대한 이동 프로퍼티
        만약 요소 노드가 아닌 다른 노드들을 이동하고 싶은 경우에는 아래와 같은 프로퍼티를 활용할 수도 있습니다.

        프로퍼티 유형 결과
        node.childNodes 자식 노드 node의 자식 노드 모음(NodeList)
        node.firstChild 자식 노드 node의 첫 번째 자식 노드 하나
        node.lastChild 자식 노드 node의 마지막 자식 노드 하나
        node.parentNode 부모 노드 node의 부모 요소 하나
        node.previousSibling 형제 노드 node의 이전(previous) 혹은 좌측(left)에 있는 노드 하나
        node.nextSibling 형제 노드 node의 다음(next) 혹은 우측(right)에 있는 노드 하나
        대부분 요소 노드의 프로퍼티 이름에서 Element라는 단어만 빠진 것 같은데요.
        사실 모든 노드가 공통적으로 갖고있는 이 프로퍼티들은 특별한 경우를 제외하면 자주 사용되진 않습니다.

        그 이유는 DOM 트리가 만들어질 때 생겨나는 노드들을 좀 더 자세히 살펴보면 알 수 있는데요.

        DOM 트리를 구성할 때..
        브라우저가 HTML 코드를 해석할 때 각 코드들은 상황에 맞게 node를 생성하고 DOM 트리를 구성하는데,

        HTML 태그는 요소 노드가 되고,
        문자들은 텍스트 노드,
        그리고 주석도 주석 노드로 DOM 트리에 반영됩니다.

        <!DOCTYPE HTML>
        <html>

        <head>
            <title>JavaScript</title>
        </head>

        <body>
            I Love JavaScript
            <!-- I Love Codeit -->
        </body>

        </html>
        예를 들어 이런 코드는 아래와 같이 DOM 트리를 구성하게 되는데요.

        DOM트리여행하기

        그런데 텍스트 노드 중에서 붉은 테두리가 있는 부분을 통해 알 수 있듯 태그와 태그사이에 줄 바꿈과 들여쓰기로 인한 띄어쓰기도 텍스트 노드(Text라고 표시된 부분)로 생성된 모습을 확인할 수
        있습니다.

        지금 예시는 간단하기 때문에 어느 정도 DOM 트리를 예상할 수 있지만, 조금만 더 코드가 복잡하거나 혹은 코드의 스타일이 일정하지 않은 경우에는 이런 줄 바꿈과 들여쓰기로 인해 생성된 텍스트 노드의
        존재를 파악하기가 쉽지 않을 수 있습니다.

        그래서 방금 본, 모든 노드가 공통으로 갖고 있는 프로퍼티를 활용한다면, 예상치 못한 텍스트 노드를 선택하게 되어 의도하지 않은 결과를 만들어 낼 가능성이 커지게 됩니다.

        일반적으로 우리가 다루고자 하는 대상은 태그!
        자바스크립트로 웹 문서를 다룰 때는 아무래도 텍스트 노드보다는 요소 노드를 다룰 경우가 더 많을 겁니다.
        만약 여러분이 의도하는 대상이 HTML 태그라면 요소 노드에 대한 이동 프로퍼티를 활용하는 것이 훨씬 더 안전하겠죠?

        그래도 상황에 따라서는 요소 노드가 아닌 노드들을 이동시켜야할 수도 있으니 모든 노드가 공통으로 갖고 있는 속성들도 잘 기억해주세요.

        잘 기억해 두시면 충분히 도움이 될겁니다!
    </h2>

    <h3>
        지난 시간에 살펴본 요소 노드의 프로퍼티들을 한 번 더 복습하고 넘어갑시다!

        <!DOCTYPE html>
        <html lang="ko">

        <head>
            <meta charset="UTF-8">
            <title>JS with Codeit</title>
        </head>

        <body>
            <div id="content">
                <h2 id="title-1">Cat-1</h1>
                    <ul id="list-1">
                        <li>Ragdoll</li>
                        <li>British Shorthair</li>
                        <li>Scottish Fold</li>
                        <li>Bengal</li>
                        <li>Siamese</li>
                        <li>Maine Coon</li>
                        <li>American Shorthair</li>
                        <li>Russian Blue</li>
                    </ul>
                    <h2 id="title-2">Cat-2</h1>
                        <ul id="list-2">
                            <li>Sphynx</li>
                            <li>Munchkin</li>
                            <li>Persian</li>
                            <li>Norwegian Forset</li>
                            <li>Turkish Angora</li>
                            <li>Bombay</li>
                            <li>Selkirk Rex</li>
                            <li>Munchkin</li>
                        </ul>
            </div>
            <script src="index.js"></script>
        </body>

        </html>
        1. element.innerHTML
        요소 노드 내부의 HTML 코드를 문자열로 리턴해 줍니다. (내부에 있는 줄 바꿈이나 들여쓰기 모두 포함합니다.)
        const myTag = document.querySelector('#list-1');

        // innerHTML
        console.log(myTag.innerHTML);
        innerHTMLouterHTMLtextContent

        요소 안의 정보를 확인할 수도 있지만, 내부의 HTML 자체를 수정할 때 좀 더 자주 활용됩니다. (내부에 있던 값을 완전히 새로운 값으로 교체하기 때문에 주의해서 사용해야해요!)
        const myTag = document.querySelector('#list-1');

        // innerHTML
        console.log(myTag.innerHTML);
        myTag.innerHTML = '<li>Exotic</li>';
        console.log(myTag.innerHTML);
        innerHTMLouterHTMLtextContent-2

        2. element.outerHTML
        요소 노드 자체의 전체적인 HTML 코드를 문자열로 리턴해줍니다. (내부에 있는 줄 바꿈이나 들여쓰기 모두 포함합니다.)
        const myTag = document.querySelector('#list-1');

        // outerHTML
        console.log(myTag.outerHTML);
        innerHTMLouterHTMLtextContent-3

        outerHTML은 새로운 값을 할당할 경우 요소 자체가 교체되어 버리기 때문에 주의해야 합니다.
        const myTag = document.querySelector('#list-1');

        // outerHTML
        console.log(myTag.outerHTML);
        myTag.outerHTML = '<ul id="new-list">
            <li>Exotic</li>
        </ul>';
        innerHTMLouterHTMLtextContent-4

        3. element.textContent
        요소 안의 내용들 중에서 HTML 태그 부분은 제외하고 텍스트만 가져옵니다. (내부에 있는 줄 바꿈이나 들여쓰기 모두 포함합니다.)
        const myTag = document.querySelector('#list-1');

        // textContext
        console.log(myTag.textContent);
        innerHTMLouterHTMLtextContent-5

        새로운 값을 할당하면 innerHTML과 마찬가지로 내부의 값을 완전히 새로운 값으로 교체 합니다.
        const myTag = document.querySelector('#list-1');

        // textContext
        console.log(myTag.textContent);
        myTag.textContent = 'new text!';
        innerHTMLouterHTMLtextContent-6

        하지만 textContent는 말그대로 텍스트만 다루기 때문에, 특수문자도 그냥 텍스트로 처리한다는 점, 꼭 기억해주세요!
        const myTag = document.querySelector('#list-1');

        // textContext
        console.log(myTag.textContent);
        myTag.textContent = '<li>new text!</li>';
        innerHTMLouterHTMLtextContent-7
    </h3>

    <h4>ch02 정리
        1. window 객체
        window 객체는 브라우저 창을 대변하면서 자바스크립트에서 최상단에 존재하는 객체입니다.
        자바스크립트 코드 어느 곳에서나 항상 접근할 수 있는 객체이기 때문에 전역 객체, 영어로는 Global Object라고 부릅니다.
        어떤 프로퍼티나 메소드를 사용하든 결국 전역 객체 내부의 것이기 때문에 앞에 window.을 생략할 수도 있습니다.

        2. DOM
        DOM이란 Document Object Model의 약자로, 한국어로는 문서 객체 모델입니다.
        간단하게 표현하면 웹 페이지에 나타나는 HTML 문서 전체를 객체로 표현한 것으로 생각하면 됩니다.
        이때 각 객체를 노드(Node)라는 용어로 표현하고, 태그는 요소 노드, 문자는 텍스트 노드로 구분됩니다.

        3. DOM 트리
        HTML의 계층 구조는 DOM에서도 반영되는데 이러한 계층구조를 나무에 비유해서 DOM 트리라고 부릅니다.
        각 노드 간의 관계는 부모, 자식, 형제라는 용어로 표현합니다.

        4. DOM 이동 시 활용 가능한 프로퍼티
        프로퍼티 유형 결과
        element.children 자식 요소 노드 element의 자식 요소 모음(HTMLCollection)
        element.firstElementChild 자식 요소 노드 element의 첫 번째 자식 요소 하나
        element.lastElementChild 자식 요소 노드 element의 마지막 자식 요소 하나
        element.parentElement 부모 요소 노드 element의 부모 요소 하나
        element.previousElementSibling 형제 요소 노드 element의 이전(previous) 혹은 좌측(left)에 있는 요소 하나
        element.nextElementSibling 형제 요소 노드 element의 다음(next) 혹은 우측(right)에 있는 요소 하나
        node.childNodes 자식 노드 node의 자식 노드 모음(NodeList)
        node.firstChild 자식 노드 node의 첫 번째 자식 노드 하나
        node.lastChild 자식 노드 node의 마지막 자식 노드 하나
        node.parentNode 부모 노드 node의 부모 요소 하나
        node.previousSibling 형제 노드 node의 이전(previous) 혹은 좌측(left)에 있는 노드 하나
        node.nextSibling 형제 노드 node의 다음(next) 혹은 우측(right)에 있는 노드 하나
        5. 주요 요소 노드 프로퍼티
        프로퍼티 내용 참고사항
        element.innerHTML 요소 노드 내부의 HTML코드 문자열로 리턴 요소 안의 정보를 확인할 수도 있지만,
        내부의 HTML 자체를 수정할 때 좀 더 자주 활용
        element.outerHTML 요소 노드 자체의 전체적인 HTML 코드를 문자열로 리턴 outerHTML은 새로운 값을 할당하면
        요소 자체가 교체되어 버리기 때문에 주의
        element.textContent 요소 노드 내부의 내용들 중에서 HTML을 제외하고 텍스트만 리턴 textContent는 말그대로 텍스트만 다루기 때문에
        HTML태그를 쓰더라도 모두 텍스트로 처리됨
        6. 요소 노드 다루기
        요소 노드 만들기: document.createElement('태그이름')
        요소 노드 꾸미기: element.textContent, element.innerHTML, ...
        요소 노드 추가 혹은 이동하기: element.prepend, element.append, element.after, element.before
        요소 노드 삭제하기: element.remove()
        7. HTML 속성 다루기
        대부분의 HTML 속성은 DOM 객체의 프로퍼티로 변환이 됩니다.
        하지만, 표준 속성이 아닌 경우에는 프로퍼티로 변환이 안 되는데요. 아래 메소드를 활용하면 표준이 아닌 HTML 속성들도 다룰 수 있습니다.

        속성에 접근하기: element.getAttribute('속성')
        속성 추가(수정)하기: element.setAttribute('속성', '값')
        속성 제거하기: element.removeAttribute('속성')
        8. 스타일 다루기
        자바스크립트로 태그의 스타일을 다루는 방법에는 크게 두 가지가 있습니다.

        style 프로퍼티 활용하기: element.style.styleName = 'value';
        class 변경을 통해 간접적으로 스타일 적용하기: element.className, element.classList
        8-1. classList의 유용한 메소드
        메소드 내용 참고사항
        classList.add 클래스 추가하기 여러 개의 값을 전달하면 여러 클래스 추가 가능
        classList.remove 클래스 삭제하기 여러 개의 값을 전달하면 여러 클래스 삭제 가능
        classList.toggle 클래스 없으면 추가, 있으면 삭제하기 하나의 값만 적용 가능하고,
        두 번째 파라미터로 추가 또는 삭제 기능을 강제할 수 있음

    </h4>

</body>

</html>